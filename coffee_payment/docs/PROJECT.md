# Coffee Payments Server — Документация проекта

## Краткое описание бизнес-задачи

Проект — это **MVP версия** сервера для обработки платежей в системе кофейных автоматов. Он предоставляет API для управления устройствами (кофемашинами), обработки заказов напитков и интеграции с платежными системами (ЮKassa, ТБанк). Сервис позволяет мерчантам (владельцам кофемашин) принимать платежи, отслеживать статус заказов. Система предназначена для автоматизации оплаты напитков в сетях кофейных автоматов.

## Используемые технологии

### Языки программирования
- **Python 3.x** — основной язык разработки бэкенда

### Фреймворки и библиотеки
- **Django 5.1.4** — веб-фреймворк для создания REST API и обработки HTTP-запросов
- **Django REST Framework 3.15.2** — расширение для более удобной работы с REST API
- **Requests 2.32.3** — библиотека для выполнения HTTP-запросов к внешним API
- **Paho MQTT 2.1.0** — клиент MQTT для взаимодействия с IoT-устройствами
- **YooKassa 3.5.0** — SDK для интеграции с платежной системой ЮKassa
- **Psycopg2 2.9.10** — драйвер для подключения к PostgreSQL

### База данных
- **PostgreSQL** — реляционная СУБД для хранения данных о мерчантах, устройствах, заказах и платежах

### Инструменты сборки, тестирования и деплоя
- **Docker** — контейнеризация приложения
- **Docker Compose** — орхестрация контейнеров для локального развертывания
- **pip** — менеджер пакетов Python
- **Django ORM** — встроенная система управления моделями данных

## Архитектура проекта

### Архитектурный паттерн
Проект использует классическую **MVC архитектуру** (Model-View-Controller) с элементами REST API:

- **Models** — определяют структуру данных в БД (Merchant, Device, Order, Payment, Receipt и т.д.)
- **Views** — обрабатывают HTTP-запросы и возвращают ответы (JSON или HTML)
- **Controllers** — встроены в Views, управляют бизнес-логикой
- **Services** — отдельные модули для работы с внешними API (Tmetr, YooKassa, QR-коды)

### Основные компоненты системы

#### 1. **API слой (Views)**
- `process_payment_flow()` — основная функция обработки платежного потока после сканирования QR-кода, включает валидацию устройства, создание заказа и маршрутизацию по платежным сценариям
- `initiate_payment()` — инициация платежа после подтверждения заказа пользователем
- `yookassa_payment_result_webhook()` — обработка webhook'ов от платежных систем
- Управление заказами и статусами

#### 2. **Сервисный слой (Services)**
- `payment_scenario_service.py` — управление сценариями оплаты и маршрутизация платежей
- `yookassa_service.py` — интеграция с платежной системой ЮKassa
- `t_bank_service.py` — интеграция с платежной системой TBank
- `tmetr_service.py` — интеграция с API Tmetr для управления кофемашинами
- `qr_code_service.py` — валидация устройств и мерчантов
- `telemetry_service.py` — получение информации о напитках с устройств
- `validation_service.py` — цепочка валидаций заказов перед обработкой платежа

#### 3. **Слой данных (Models)**
- `Merchant` — информация о владельцах кофемашин
- `Device` — данные о кофемашинах (статус, локация, привязка к мерчанту, сценарий оплаты, логотип, информация для клиентов, информация для клиентов при ошибках, статус-специфичная информация для страницы отслеживания заказа)
- `MerchantCredentials` — учетные данные мерчантов для различных платежных сценариев (Yookassa, TBank, Custom)
- `Drink` — каталог напитков с ценами
- `Order` — заказы напитков с детализированной статусной моделью (7 статусов), механизмом протухания и сохранением drink_number из QR-кода
- `Payment` — информация о платежах
- `Receipt` — чеки для отправки пользователям
- `TBankPayment` — платежи через Tbank

#### 4. **Утилиты**
- `logging.py` — централизованное логирование всех операций
- `user_messages.py` — централизованное хранение пользовательских сообщений об ошибках

### Взаимодействие компонентов

```
Клиент (QR-код с кофемашины)
        ↓
GET /v1/pay → process_payment_flow()
        ↓
    ┌───────────────────────┐
    │  Валидация параметров │
    └───────────────────────┘
        ↓
    ┌───────────────────────────────────────┐
    │  ЦЕПОЧКА ВАЛИДАЦИЙ                    │
    │  (Validation Service)                 │
    │                                       │
    │  1. Валидация хеша запроса            │
    │     (placeholder - всегда успешно)    │
    │          ↓                            │
    │  2. Проверка существования заказа     │
    │     - Заказ не существует → создать   │
    │     - Заказ существует и валиден →    │
    │       использовать существующий       │
    │     - Заказ протух → ошибка           │
    │          ↓                            │
    │  3. Проверка статуса устройства       │
    │     (heartbeat через Tmetr API)       │
    │     - Устройство онлайн → продолжить  │
    │     - Устройство офлайн → ошибка      │
    │                                       │
    │  При любой ошибке → показать экран    │
    │  ошибки и прервать обработку          │
    └───────────────────────────────────────┘
        ↓
    ┌───────────────────────┐
    │  Валидация Device +   │
    │  Merchant             │
    │  (QR Code Service)    │
    └───────────────────────┘
        ↓
    ┌───────────────────────┐
    │  Получение информации │
    │  о напитке            │
    │  (Tmetr Service)      │
    └───────────────────────┘
        ↓
    ┌───────────────────────┐
    │  Создание Order       │
    │  (если требуется)     │
    │  (status='created')   │
    └───────────────────────┘
        ↓
    ┌───────────────────────┐
    │  Определение Payment  │
    │  Scenario             │
    └───────────────────────┘
        ↓
    ┌─────────────────────────────────────┐
    │                                     │
    ▼                                     ▼
Yookassa/TBank                      Custom
    │                                     │
    ▼                                     ▼
show_order_info()              execute_custom_scenario()
    │                                     │
    ▼                                     │
initiate_payment()                       │
    │                                     │
    ▼                                     ▼
Payment Service (создание платежа)
    │
    ↓
   Redirect to Payment URL
        ↓
[Пользователь оплачивает]
        ↓
    Платежная система перенаправляет на
    /v1/order-status-page?order_id=...
        ↓
    ┌───────────────────────────────────┐
    │ Страница отслеживания статуса     │
    │ (show_order_status_page)          │
    │                                   │
    │ - Отображает информацию о заказе  │
    │ - Polling каждую секунду          │
    │   (GET /v1/order-status/<id>)     │
    │ - Обновляет UI без перезагрузки   │
    │ - Кнопка "Повторить оплату"       │
    │   для статуса not_paid            │
    └───────────────────────────────────┘
        ↑
        │ (параллельно)
        ↓
    Webhook от платежной системы
        ↓
    ┌───────────────────────┐
    │ Update Order Status   │
    │ (Models)              │
    │ pending → paid        │
    └───────────────────────┘
        ↓
    ┌───────────────────────┐
    │ Tmetr Service         │
    │ (отправить команду    │
    │  приготовления)       │
    └───────────────────────┘
        ↓
    ┌───────────────────────┐
    │ Update Order Status   │
    │ paid → make_pending   │
    └───────────────────────┘
        ↓
    Кофемашина готовит напиток
        ↓
    ┌───────────────────────┐
    │ Update Order Status   │
    │ make_pending →        │
    │ successful            │
    └───────────────────────┘
```

## Основные файлы и директории

### Корневая директория
```
coffee_payment/                    # Корневая папка проекта
├── README.md                      # Основная документация проекта
├── requirements.txt               # Зависимости Python
├── manage.py                      # Управление Django проектом
├── docker-compose.yml             # Конфигурация для запуска в Docker
├── Dockerfile                     # Образ приложения
├── entrypoint.sh                  # Скрипт инициализации контейнера
└── run.sh                         # Скрипт для локального запуска
```

### Папка `coffee_payment/` — конфигурация Django
```
coffee_payment/
├── __init__.py                    # Инициализация пакета
├── settings.py                    # Основные настройки проекта (БД, приложения, API ключи)
├── urls.py                        # Маршруты приложения
├── asgi.py                        # ASGI конфигурация для async серверов
├── wsgi.py                        # WSGI конфигурация для WSGI серверов
└── __pycache__/                   # Кэш скомпилированного Python кода
```

### Папка `payments/` — основное приложение
```
payments/
├── __init__.py
├── admin.py                       # Регистрация моделей в Django Admin
├── apps.py                        # Конфигурация приложения
├── models.py                      # Модели данных (Merchant, Device, Order, Payment и т.д.)
├── tests.py                       # Тесты приложения
├── views.py                       # API endpoints и обработчики запросов
├── migrations/                    # Миграции базы данных
│   ├── __init__.py
│   ├── 0001_initial.py            # Начальная миграция
│   ├── 0002_...py                 # Последующие изменения схемы
│   └── ...
├── services/                      # Сервисы для работы с внешними API
│   ├── payment_scenario_service.py # Управление сценариями оплаты
│   ├── yookassa_service.py        # Интеграция с ЮKassa
│   ├── t_bank_service.py          # Интеграция с TBank
│   ├── tmetr_service.py           # Интеграция с Tmetr API
│   ├── qr_code_service.py         # Обработка QR-кодов
│   ├── telemetry_service.py       # Получение телеметрии с устройств
│   ├── validation_service.py      # Цепочка валидаций заказов
│   ├── mqtt_yaclient.py           # MQTT клиент для Yandex Cloud
│   ├── cm_mqtt.py                 # MQTT команды для кофемашин
│   └── __pycache__/
├── utils/                         # Вспомогательные утилиты
│   ├── logging.py                 # Централизованное логирование
│   └── __pycache__/
└── __pycache__/
```

### Папка `templates/` — HTML шаблоны
```
templates/
└── payments/
    ├── error_page.html            # Современный адаптивный экран ошибки с брендингом
    ├── receipt_data_form.html     # Форма для ввода данных чека
    ├── order_info_screen.html     # Экран информации о заказе перед оплатой
    └── order_status_page.html     # Страница отслеживания статуса заказа в реальном времени
```

### Папка `static/` — статические файлы
```
static/                           # CSS, JS, изображения (если требуется)
```

### Папка `docs/` — документация
```
docs/                             # Папка с документацией проекта
└── PROJECT.md                     # Этот файл
```

### Папка `logs/` — логи приложения
```
logs/                             # Логи выполнения приложения
```

## Основные потоки данных

### 1. Инициирование платежа (QR-код)
1. Клиент сканирует QR-код на кофемашине
2. Запрос попадает в `process_payment_flow()` через URL `/v1/pay`
3. Валидируются все обязательные параметры (deviceUuid, drinkNo, drinkName, size, uuid)
4. Проверяется существование Device и активность Merchant через функции `validate_device()` и `validate_merchant()` из qr_code_service
5. Получается информация о напитке из Tmetr API
6. Создается Order со статусом `created` и временем протухания (expires_at)
7. Определяется платежный сценарий для устройства (`device.payment_scenario`)
8. **Для Yookassa/TBank**: отображается экран информации о заказе с деталями напитка, ценой и кнопкой "Перейти к оплате"
9. **Для Custom**: выполняется прямой редирект на внешний URL через `PaymentScenarioService.execute_scenario()`

### 2. Обработка платежа (после подтверждения заказа)
1. Пользователь нажимает кнопку "Перейти к оплате" на экране информации
2. Вызывается `initiate_payment()` через POST-запрос
3. Проверяется, не протух ли заказ (expires_at)
4. Создается платеж через API платежной системы (Yookassa или TBank)
5. Статус Order меняется на `pending`
6. Пользователь редиректится на страницу оплаты платежной системы

### 3. Обработка результата платежа (Webhook)
1. YooKassa отправляет webhook при успешном платеже
2. `yookassa_payment_result_webhook()` проверяет, не протух ли заказ
3. Статус Order обновляется: `pending` → `paid` (при успехе) или `not_paid` (при отмене)
4. Отправляется команда на кофемашину через Tmetr API, статус меняется на `make_pending`
5. После приготовления статус меняется на `successful`
6. При критических ошибках статус меняется на `failed`

## Цепочка валидаций заказов

Система использует многоуровневую цепочку валидаций для проверки корректности запросов и состояния оборудования перед обработкой платежа. Валидации выполняются последовательно с прерыванием на первой ошибке.

### Архитектура валидации

Цепочка валидаций интегрирована в функцию `process_payment_flow()` и выполняется после валидации параметров запроса, но до создания заказа и маршрутизации по платежным сценариям.

**Последовательность валидаций:**

1. **Валидация хеша запроса** — проверка подлинности запроса (placeholder реализация)
2. **Проверка существования заказа** — проверка, не создан ли уже заказ с данным UUID
3. **Проверка статуса устройства** — проверка, что кофемашина онлайн через Tmetr heartbeat API

При любой ошибке валидации:
- Цепочка прерывается
- Пользователю показывается экран ошибки с понятным сообщением
- Техническая информация логируется для отладки
- Дальнейшая обработка запроса не выполняется

### Компоненты валидации

#### OrderValidationService

Сервис, инкапсулирующий всю логику валидаций.

**Расположение:** `coffee_payment/payments/services/validation_service.py`

**Основные методы:**

```python
class OrderValidationService:
    @staticmethod
    def validate_request_hash(request_params: dict) -> tuple[bool, str]:
        """
        Валидация хеша запроса для проверки подлинности.
        Текущая реализация — placeholder, всегда возвращает успех.
        """
        
    @staticmethod
    def check_order_existence(order_uuid: str) -> tuple[bool, str, Order | None]:
        """
        Проверка существования заказа и его состояния.
        Возвращает: (нужно_создать_новый, сообщение_об_ошибке, существующий_заказ)
        """
        
    @staticmethod
    def check_device_online_status(device_uuid: str) -> tuple[bool, str]:
        """
        Проверка онлайн-статуса устройства через Tmetr heartbeat API.
        Возвращает: (устройство_онлайн, сообщение_об_ошибке)
        """
        
    @staticmethod
    def execute_validation_chain(request_params: dict, device_uuid: str, order_uuid: str) -> dict:
        """
        Выполнение полной цепочки валидаций с ранним прерыванием.
        Возвращает словарь с результатами валидации.
        """
```

#### Расширение TmetrService

Добавлен метод для получения heartbeat данных устройства:

```python
def get_device_heartbeat(self, device_id: str) -> Dict[str, Any]:
    """
    Получение последнего heartbeat устройства из Tmetr API.
    
    Endpoint: POST /api/ui/v1/stat/heartbeat/recent
    Headers: X-TimeZoneOffset (часовой пояс сервера)
    
    Возвращает данные о последнем сигнале устройства с timestamp.
    """
```

**API Endpoint:** `POST https://{TMETR_HOST}/api/ui/v1/stat/heartbeat/recent`

**Заголовки:**
- `Authorization: Bearer {TMETR_TOKEN}`
- `X-TimeZoneOffset: {timezone_offset}` — смещение часового пояса сервера в минутах

**Тело запроса:**
```json
{
  "deviceIds": ["device-uuid"],
  "offset": 0,
  "limit": 1
}
```

**Ответ:**
```json
{
  "content": [
    {
      "deviceId": "device-uuid",
      "deviceIotName": "device-name",
      "heartbeatCreatedAt": 1699876543000
    }
  ],
  "totalElements": 1,
  "offset": 0,
  "limit": 1
}
```

### Детали валидаций

#### 1. Валидация хеша запроса

**Цель:** Проверка подлинности запроса, защита от подделки QR-кодов.

**Текущая реализация:** Placeholder, всегда возвращает успех. Позволяет добавить реальную валидацию позже без изменения интерфейса.

**Логирование:** Все попытки валидации логируются с параметрами запроса.

**Сообщение об ошибке:** `invalid_request_hash` — "Некорректный запрос. Пожалуйста, отсканируйте QR-код снова."

#### 2. Проверка существования заказа

**Цель:** Предотвращение создания дубликатов заказов, возможность продолжить существующий заказ.

**Логика:**
- Если заказ не существует → создать новый заказ
- Если заказ существует со статусом `created` и не протух → использовать существующий
- Если заказ существует, но протух (expires_at < текущее время) → показать ошибку
- Если заказ существует с другим статусом → создать новый заказ

**Проверка протухания:** Используется метод `Order.is_expired()` для проверки поля `expires_at`.

**Логирование:** UUID заказа, статус, результат проверки.

**Сообщение об ошибке:** Используется существующее сообщение для протухших заказов.

#### 3. Проверка статуса устройства

**Цель:** Убедиться, что кофемашина онлайн и может приготовить напиток.

**Логика:**
1. Отправить запрос к Tmetr heartbeat API с UUID устройства
2. Получить timestamp последнего heartbeat (`heartbeatCreatedAt`)
3. Вычислить разницу между текущим временем и временем heartbeat
4. Сравнить с порогом из настроек (`DEVICE_ONLINE_THRESHOLD_MINUTES`)
5. Если разница превышает порог → устройство офлайн
6. Если разница в пределах порога → устройство онлайн

**Обработка ошибок API:**
- Ошибки сети → устройство считается недоступным
- Ошибки API (4xx/5xx) → показать ошибку проверки heartbeat
- Отсутствие данных heartbeat → устройство офлайн

**Работа с часовыми поясами:**
- Timestamp heartbeat приходит в часовом поясе сервера
- Используется Django timezone-aware datetime для корректного сравнения
- В запрос включается заголовок `X-TimeZoneOffset`

**Логирование:** UUID устройства, timestamp heartbeat, результат проверки (онлайн/офлайн), порог.

**Сообщения об ошибках:**
- `device_offline` — "Кофемашина недоступна. Пожалуйста, попробуйте другое устройство или обратитесь к администратору."
- `heartbeat_check_failed` — "Не удалось проверить статус устройства. Пожалуйста, попробуйте позже."

### Конфигурация

#### Настройки в settings.py

```python
# Порог онлайн-статуса устройства в минутах
# Если последний heartbeat старше этого значения, устройство считается офлайн
DEVICE_ONLINE_THRESHOLD_MINUTES = 5
```

**Рекомендуемые значения:**
- Для стабильных сетей: 5 минут
- Для нестабильных сетей: 10-15 минут
- Для тестирования: 1-2 минуты

#### Сообщения об ошибках

Все сообщения хранятся в `coffee_payment/payments/user_messages.py`:

```python
ERROR_MESSAGES = {
    # ... существующие сообщения ...
    'invalid_request_hash': 'Некорректный запрос. Пожалуйста, отсканируйте QR-код снова.',
    'device_offline': 'Кофемашина недоступна. Пожалуйста, попробуйте другое устройство или обратитесь к администратору.',
    'heartbeat_check_failed': 'Не удалось проверить статус устройства. Пожалуйста, попробуйте позже.',
}
```

### Интеграция в process_payment_flow

Цепочка валидаций интегрирована в основной поток обработки платежа:

```python
def process_payment_flow(request):
    # 1. Извлечение и валидация параметров
    device_uuid = request.GET.get('deviceUuid')
    order_uuid = request.GET.get('uuid')
    # ... другие параметры ...
    
    # 2. НОВОЕ: Выполнение цепочки валидаций
    validation_result = OrderValidationService.execute_validation_chain(
        request_params={...},
        device_uuid=device_uuid,
        order_uuid=order_uuid
    )
    
    # 3. Обработка результата валидации
    if not validation_result['valid']:
        return render_error_page(validation_result['error_message'], 400)
    
    # 4. Продолжение обработки (валидация device/merchant, получение данных о напитке)
    # ...
    
    # 5. Условное создание заказа
    if validation_result['should_create_new_order']:
        order = Order.objects.create(...)
    else:
        order = validation_result['existing_order']
    
    # 6. Маршрутизация по платежному сценарию
    # ...
```

### Логирование

Все этапы валидации подробно логируются:

**Формат логов:**
```
[timestamp] [уровень] [функция] сообщение с контекстом
```

**Примеры:**
```
[2025-11-13T10:30:00+03:00] INFO [execute_validation_chain] Starting validation chain. device_uuid=abc-123, order_uuid=xyz-789
[2025-11-13T10:30:00+03:00] INFO [validate_request_hash] Hash validation passed (placeholder)
[2025-11-13T10:30:00+03:00] INFO [check_order_existence] Order xyz-789 not found, will create new order
[2025-11-13T10:30:01+03:00] INFO [check_device_online_status] Checking device abc-123 heartbeat
[2025-11-13T10:30:01+03:00] INFO [check_device_online_status] Device abc-123 is online. Last heartbeat: 2025-11-13T10:28:00+03:00, threshold: 5 minutes
[2025-11-13T10:30:01+03:00] INFO [execute_validation_chain] Validation chain completed successfully
```

**При ошибках:**
```
[2025-11-13T10:30:01+03:00] ERROR [check_device_online_status] Device abc-123 is offline. Last heartbeat: 2025-11-13T10:20:00+03:00, threshold: 5 minutes
[2025-11-13T10:30:01+03:00] INFO [execute_validation_chain] Validation chain failed at device status check
```

### Пользовательский опыт

**Успешная валидация:**
- Пользователь не замечает валидацию
- Процесс продолжается без задержек (~1-2 секунды на Tmetr API запрос)

**Ошибка валидации:**
- Показывается экран ошибки с понятным сообщением
- Используется существующий шаблон `error_page.html`
- Mobile-first дизайн, адаптивная верстка
- Технические детали скрыты от пользователя
- HTTP статус 400 (Bad Request)

### Мониторинг и метрики

Рекомендуется отслеживать:
- Частоту отказов валидации по типам
- Частоту обнаружения офлайн устройств
- Время ответа Tmetr heartbeat API
- Частоту протухания заказов

### Будущие улучшения

1. **Реализация валидации хеша** — добавить криптографическую проверку подлинности запросов
2. **Кеширование heartbeat** — кешировать статус устройства на 30-60 секунд для снижения нагрузки на API
3. **Настраиваемая цепочка** — возможность включать/отключать отдельные валидации через настройки
4. **Retry логика** — автоматические повторные попытки при временных ошибках Tmetr API
5. **Метрики валидации** — сбор статистики производительности и паттернов ошибок

## Статусная модель заказов

Система использует детализированную статусную модель для отслеживания жизненного цикла заказа:

1. **created** — Заказ создан после валидации
2. **pending** — Платеж создан, ожидается оплата
3. **paid** — Оплата прошла успешно
4. **not_paid** — Оплата не прошла
5. **make_pending** — Команда на приготовление отправлена
6. **successful** — Заказ успешно завершен
7. **failed** — Заказ не может быть завершен (критическая ошибка)

### Механизм протухания заказов

Каждый заказ имеет поле `expires_at`, которое автоматически устанавливается при создании. Время протухания настраивается через параметр `ORDER_EXPIRATION_MINUTES` (по умолчанию 15 минут). Протухшие заказы не обрабатываются системой.

## Конфигурация сценариев оплаты

Система поддерживает гибкую настройку платежных сценариев для каждой кофемашины. Это позволяет использовать различных платежных провайдеров и интегрироваться с внешними системами оплаты.

### Доступные сценарии оплаты

Система поддерживает три типа платежных сценариев:

1. **Yookassa** — интеграция с платежной системой ЮKassa (по умолчанию)
2. **TBank** — интеграция с платежной системой TBank
3. **Custom** — перенаправление на внешнюю систему оплаты

Список доступных сценариев настраивается в `settings.py`:

```python
PAYMENT_SCENARIOS = ['Yookassa', 'TBank', 'Custom']
DEFAULT_PAYMENT_SCENARIO = 'Yookassa'
```

### Модель Device

Каждая кофемашина (Device) имеет поле `payment_scenario`, которое определяет, какой сценарий оплаты будет использоваться для этого устройства:

```python
class Device(models.Model):
    # ... другие поля ...
    payment_scenario = models.CharField(
        max_length=50,
        default='Yookassa',
        help_text='Payment scenario for this device'
    )
    logo_url = models.URLField(
        null=True, 
        blank=True,
        help_text='URL to merchant logo image displayed on order screen'
    )
    client_info = models.TextField(
        null=True,
        blank=True,
        help_text='Custom information displayed to customers on order screen'
    )
    client_error_info = models.TextField(
        null=True,
        blank=True,
        help_text='Custom information displayed to customers on error screens (e.g., support contact)'
    )
```

При создании нового устройства автоматически устанавливается сценарий по умолчанию (Yookassa). Сценарий можно изменить через Django Admin или API.

**Дополнительные поля для пользовательских экранов:**
- `logo_url` — URL логотипа мерчанта, отображается на экранах заказа и ошибки
- `client_info` — произвольная информация для клиентов на экране заказа (например, контакты поддержки)
- `client_error_info` — произвольная информация для клиентов на экране ошибки с поддержкой HTML-форматирования (например, ссылки на поддержку: `<a href="tel:+79001234567">+7 900 123-45-67</a>`)

### Модель MerchantCredentials

Для каждого платежного сценария мерчант должен предоставить свои учетные данные. Они хранятся в модели `MerchantCredentials`:

```python
class MerchantCredentials(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    merchant = models.ForeignKey(Merchant, on_delete=models.CASCADE, related_name='credentials')
    scenario = models.CharField(max_length=50)
    credentials = models.JSONField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        unique_together = ('merchant', 'scenario')
```

Учетные данные хранятся в формате JSON в поле `credentials`. Каждый мерчант может иметь учетные данные для нескольких сценариев.

### Структура учетных данных

#### Yookassa Credentials

```json
{
  "account_id": "1193510",
  "secret_key": "test_Ku1e9ZkX5OoTCm0k2m05Dg66XldJFHkER_9sw5LKE1E"
}
```

Поля:
- `account_id` — идентификатор магазина в ЮKassa
- `secret_key` — секретный ключ для API ЮKassa

#### TBank Credentials

```json
{
  "shop_id": "ShopID123",
  "secret_key": "SecretKey456",
  "success_url": "https://example.com/success",
  "fail_url": "https://example.com/fail"
}
```

Поля:
- `shop_id` — идентификатор магазина в TBank
- `secret_key` — секретный ключ для API TBank
- `success_url` — URL для перенаправления при успешной оплате
- `fail_url` — URL для перенаправления при неудачной оплате

#### Custom Credentials

```json
{
  "api_key": "custom_api_key",
  "additional_param": "value"
}
```

Для сценария Custom структура credentials может быть произвольной, в зависимости от требований внешней системы оплаты. Также необходимо указать `redirect_url` в модели Device.

### Настройка учетных данных через Django Admin

1. Войдите в Django Admin (`/admin/`)
2. Перейдите в раздел "Merchant Credentials"
3. Нажмите "Add Merchant Credentials"
4. Выберите мерчанта
5. Укажите сценарий (Yookassa, TBank или Custom)
6. Введите учетные данные в формате JSON
7. Сохраните

**Важно:** Для каждой комбинации (мерчант, сценарий) может существовать только одна запись с учетными данными.

### Настройка сценария для устройства

1. Войдите в Django Admin (`/admin/`)
2. Перейдите в раздел "Devices"
3. Выберите устройство для редактирования
4. В поле "Payment scenario" выберите нужный сценарий
5. Если выбран сценарий "Custom", убедитесь, что заполнено поле "Redirect url"
6. Сохраните

### Обработка платежей

При создании заказа система автоматически:

1. Определяет сценарий оплаты для устройства (`device.payment_scenario`)
2. Получает учетные данные мерчанта для этого сценария
3. Выполняет соответствующий сценарий:
   - **Yookassa**: создает платеж через API ЮKassa с учетными данными мерчанта
   - **TBank**: создает платеж через API TBank с учетными данными мерчанта
   - **Custom**: перенаправляет пользователя на `device.redirect_url` с параметрами заказа

Если учетные данные для выбранного сценария не найдены, заказ получает статус `failed` и возвращается ошибка.

### Логирование

Все операции, связанные со сценариями оплаты, логируются:

- Выбор сценария для устройства
- Получение учетных данных мерчанта
- Обработка платежа с указанием сценария
- Ошибки при отсутствии учетных данных или некорректной конфигурации

Логи можно найти в файле `logs/coffee_payment.log`.

## Экран информации о заказе

Для сценариев Yookassa и TBank система отображает промежуточный экран с информацией о заказе перед переходом к оплате. Это повышает прозрачность процесса и позволяет пользователю проверить детали заказа.

### Отображаемая информация

- Логотип мерчанта (если настроен `logo_url`)
- Адрес кофемашины (`device.location`)
- Название напитка
- Размер напитка (маленький/средний/большой)
- Цена в рублях
- Дополнительная информация для клиентов (если настроен `client_info`)
- Кнопка "Перейти к оплате"

### Технические детали

**View функции:**
- `show_order_info()` — отображает экран с информацией о заказе
- `initiate_payment()` — обрабатывает POST-запрос при нажатии кнопки оплаты

**URL endpoint:**
- `/v1/initiate-payment` — инициация платежа после подтверждения заказа

**Шаблон:**
- `templates/payments/order_info_screen.html` — адаптивный HTML с встроенным CSS и JavaScript

**Особенности:**
- Mobile-first дизайн (320px - 1920px)
- Состояния: загрузка, успех, ошибка
- Проверка протухания заказа перед созданием платежа
- Централизованные сообщения об ошибках из `user_messages.py`

**Сценарий Custom:**
Для сценария Custom экран информации о заказе не отображается — происходит прямой редирект на внешний URL.

## Страница отслеживания статуса заказа

После завершения оплаты в платежной системе пользователь автоматически перенаправляется на страницу отслеживания статуса заказа. Эта страница отображает информацию о заказе и динамически обновляет статус в реальном времени без перезагрузки страницы.

### Отображаемая информация

- Логотип мерчанта (если настроен `logo_url`)
- Адрес кофемашины (`device.location`)
- Название напитка
- Размер напитка (маленький/средний/большой)
- Цена в рублях
- Текущий статус заказа с соответствующей иконкой
- Описание статуса
- Статус-специфичная информация для клиентов (поддерживает HTML)

### Отображение статусов

Страница отображает различные состояния в зависимости от статуса заказа:

**pending** (Ожидание оплаты):
- Иконка: анимированный спиннер
- Описание: "Проверяем оплату заказа..."
- Информация: `Device.client_info_pending`

**paid** (Оплачено):
- Иконка: галочка (успех)
- Описание: "Заказ успешно оплачен, начинаем готовить"
- Информация: `Device.client_info_paid`

**not_paid** (Оплата не прошла):
- Иконка: предупреждение (ошибка)
- Описание: "Оплата не прошла"
- Кнопка: "Повторить оплату" (создает новый запрос на оплату)
- Информация: `Device.client_info_not_paid`

**make_pending** (Приготовление):
- Иконка: анимированный спиннер
- Описание: "Готовим напиток..."
- Информация: `Device.client_info_make_pending`

**successful** (Готово):
- Иконка: галочка (успех)
- Описание: "Напиток готов"
- Информация: `Device.client_info_successful`

### Обновление статуса в реальном времени

Страница автоматически проверяет статус заказа каждую секунду, отправляя REST API запрос к серверу. При получении нового статуса интерфейс обновляется без перезагрузки страницы с плавными переходами.

**Логика polling:**
- Polling продолжается для статусов: `pending`, `paid`, `make_pending`
- Polling останавливается для терминальных статусов: `successful`, `not_paid`, `failed`

### Технические детали

**View функции:**
- `show_order_status_page()` — отображает HTML страницу со встроенным JavaScript
- `get_order_status(order_id)` — API endpoint для получения данных о статусе заказа (JSON)

**URL endpoints:**
- `/v1/order-status-page?order_id=<order_id>` — страница отслеживания статуса
- `/v1/order-status/<order_id>` — API для получения статуса заказа (используется для polling)

**Шаблон:**
- `templates/payments/order_status_page.html` — адаптивный HTML с встроенным CSS и JavaScript

**Особенности:**
- Mobile-first дизайн (320px - 1920px)
- Автоматическое обновление статуса каждую секунду
- Плавные переходы между состояниями
- Поддержка HTML в информационных полях
- Функция повторной оплаты для статуса `not_paid`
- Централизованные сообщения из `user_messages.py`
- Поддержка accessibility (high contrast mode, reduced motion)

**Новые поля Device для статус-специфичной информации:**
- `client_info_pending` — информация для статуса pending (поддерживает HTML)
- `client_info_paid` — информация для статуса paid (поддерживает HTML)
- `client_info_not_paid` — информация для статуса not_paid (поддерживает HTML)
- `client_info_make_pending` — информация для статуса make_pending (поддерживает HTML)
- `client_info_successful` — информация для статуса successful (поддерживает HTML)

### Интеграция с платежными системами

При создании платежей в Yookassa и TBank система автоматически настраивает URL для возврата пользователя на страницу отслеживания статуса:

**Yookassa:**
```python
return_url = f"https://{domain}/v1/order-status-page?order_id={order.id}"
```

**TBank:**
```python
success_url = f"https://{domain}/v1/order-status-page?order_id={order.id}"
```

Это обеспечивает бесшовный переход от оплаты к отслеживанию статуса заказа.

## Экран ошибки

Система отображает современный, адаптивный экран ошибки при возникновении проблем в процессе оплаты. Экран визуально согласован с экраном информации о заказе и предоставляет пользователю понятную информацию об ошибке.

### Отображаемая информация

- Логотип мерчанта (если настроен `logo_url`)
- Иконка предупреждения (⚠️)
- Заголовок "Ошибка"
- Пользовательское сообщение об ошибке из централизованного хранилища
- Дополнительная информация для клиентов при ошибках (если настроен `client_error_info`)

### Технические детали

**View функция:**
- `render_error_page(message, status_code, device=None)` — отображает экран ошибки с опциональным брендингом мерчанта

**Шаблон:**
- `templates/payments/error_page.html` — адаптивный HTML с встроенным CSS

**Особенности:**
- Mobile-first дизайн (320px - 1920px)
- Визуальная согласованность с экраном информации о заказе
- Централизованные сообщения об ошибках из `user_messages.py`
- Поддержка брендинга мерчанта (логотип и контактная информация)
- Graceful degradation при отсутствии логотипа или дополнительной информации
- Поддержка accessibility (high contrast mode, reduced motion)
- Все стили встроены (inline CSS), нет внешних зависимостей

**Поля Device для экрана ошибки:**
- `logo_url` — URL логотипа мерчанта, отображается на экране ошибки
- `client_error_info` — произвольная информация для клиентов при ошибках (например, контакты поддержки). Поддерживает HTML-форматирование (ссылки, выделение текста и т.д.)

**Обратная совместимость:**
Функция `render_error_page` поддерживает вызовы без параметра `device` для обратной совместимости. В этом случае отображается только сообщение об ошибке без брендинга.

**Примеры использования HTML в client_error_info:**
```html
<!-- Ссылка на телефон -->
Возникли проблемы? Позвоните нам: <a href="tel:+79001234567">+7 900 123-45-67</a>

<!-- Ссылка на email -->
Напишите нам: <a href="mailto:support@example.com">support@example.com</a>

<!-- Ссылка на сайт -->
Подробнее на нашем сайте: <a href="https://example.com/support" target="_blank">example.com/support</a>

<!-- Комбинированный пример -->
Возникли проблемы? <br>
Позвоните: <a href="tel:+79001234567">+7 900 123-45-67</a><br>
Или напишите: <a href="mailto:support@example.com">support@example.com</a>
```

## URL Endpoints

### Основные эндпоинты

- **`/v1/pay`** — основной эндпоинт для обработки QR-кодов и инициации платежного процесса (вызывает `process_payment_flow`)
- **`/v1/initiate-payment`** — инициация платежа после подтверждения заказа пользователем
- **`/v1/yook-pay-webhook`** — webhook для получения уведомлений от платежных систем
- **`/v1/order-status-page`** — страница отслеживания статуса заказа (HTML)
- **`/v1/order-status/<order_id>`** — API для получения статуса заказа (JSON, используется для polling)

### Алиасы для обратной совместимости

Для обеспечения обратной совместимости со старыми QR-кодами система поддерживает следующие алиасы:

- **`/v1/tbank-pay`** → перенаправляет на `process_payment_flow` (legacy alias)
- **`/v1/yook-pay`** → перенаправляет на `process_payment_flow` (legacy alias)

Все алиасы обрабатываются одной и той же функцией `process_payment_flow()`, которая автоматически определяет правильный платежный сценарий на основе настроек устройства.

## Переменные окружения

Необходимые переменные для работы:

```bash
TMETR_TOKEN=<JWT токен для Tmetr API>
TMETR_HOST=<хост API Tmetr (например, test.telemetry.fwsoft.ru)>
SECRET_KEY=<Django секретный ключ>
DEBUG=<True/False>
DATABASE_URL=<подключение к PostgreSQL>
ORDER_EXPIRATION_MINUTES=<время протухания заказа в минутах (по умолчанию 15)>
DEVICE_ONLINE_THRESHOLD_MINUTES=<порог онлайн-статуса устройства в минутах (по умолчанию 15)>
```

## Развертывание

### Локальное развертывание
```bash
docker-compose up -d
```

### Просмотр логов
```bash
docker-compose logs -f
```

### Остановка
```bash
docker-compose down
```
