# Generated by Kiro on 2025-11-18

from django.db import migrations, models, connection


def check_column_exists(table_name, column_name):
    """Check if a column exists in the database table."""
    with connection.cursor() as cursor:
        # Get database vendor (postgresql, sqlite, mysql, etc.)
        vendor = connection.vendor
        
        if vendor == 'postgresql':
            cursor.execute("""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name=%s AND column_name=%s
            """, [table_name, column_name])
        elif vendor == 'sqlite':
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns = [row[1] for row in cursor.fetchall()]
            return column_name in columns
        elif vendor == 'mysql':
            cursor.execute("""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_schema=DATABASE() AND table_name=%s AND column_name=%s
            """, [table_name, column_name])
        else:
            # For other databases, assume column doesn't exist (safe default)
            return False
        
        return cursor.fetchone() is not None


def add_make_failed_field(apps, schema_editor):
    """Add client_info_make_failed field to Device model if it doesn't exist."""
    Device = apps.get_model('payments', 'Device')
    db_table = Device._meta.db_table
    
    field_name = 'client_info_make_failed'
    field = models.TextField(
        blank=True, 
        null=True,
        help_text='Information displayed to customers when order status is make_failed. Supports HTML formatting.'
    )
    
    if not check_column_exists(db_table, field_name):
        # Field doesn't exist, add it
        field.set_attributes_from_name(field_name)
        with schema_editor.connection.schema_editor() as editor:
            editor.add_field(Device, field)
        print(f"Added field {field_name} to {db_table}")
    else:
        print(f"Field {field_name} already exists in {db_table}, skipping")


def reverse_make_failed_field(apps, schema_editor):
    """Remove client_info_make_failed field from Device model if it exists."""
    Device = apps.get_model('payments', 'Device')
    db_table = Device._meta.db_table
    
    field_name = 'client_info_make_failed'
    field = models.TextField(blank=True, null=True)
    
    if check_column_exists(db_table, field_name):
        field.set_attributes_from_name(field_name)
        with schema_editor.connection.schema_editor() as editor:
            editor.remove_field(Device, field)
        print(f"Removed field {field_name} from {db_table}")
    else:
        print(f"Field {field_name} doesn't exist in {db_table}, skipping removal")


class Migration(migrations.Migration):

    dependencies = [
        ('payments', '0018_add_device_status_client_info_fields'),
    ]

    operations = [
        # Add client_info_make_failed field to Device model
        migrations.RunPython(add_make_failed_field, reverse_make_failed_field),
        
        # Update Order.status field to include make_failed choice
        migrations.AlterField(
            model_name='order',
            name='status',
            field=models.CharField(
                max_length=50,
                choices=[
                    ('created', 'Created'),
                    ('pending', 'Pending'),
                    ('paid', 'Paid'),
                    ('not_paid', 'Not Paid'),
                    ('make_pending', 'Make Pending'),
                    ('successful', 'Successful'),
                    ('failed', 'Failed'),
                    ('make_failed', 'Make Failed'),
                ]
            ),
        ),
    ]
